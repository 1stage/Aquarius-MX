MX BASIC Documentation
======================

Generated by makedoc.py

---
## & Operator
Get Variable Address
### FORMAT:
 - &*varname*
   - Action: Returns the address of the first byte of data identified with variable *varname*.
     - Variable *varname* can be either a simple variable or an indexed array element, either string or numeric in both cases.
     - For numeric variables and array elements, the returned address points to the binary floating point number.
     - For string variables and array elements, the returned address points to the string descriptor.
     - If the varible or array does not exist, it is automatically created.
     - The address returned will be an integer in the range of 0 and 65535.
 - &&*varname*
   - Action: Returns the address of the first byte of the string text associated with *stringvar*.
     - Variable *arrayname* can be either a simple string variable or string array element.
     - Returns TM error if *varname* is not a string variable.
     - If the variable or array does not exist, it is automatically created.
     - Returns 0 if the variable or array element was automatically created.
 - &\**arrayname*
   - Action: Returns the address of the first byte of data identified with array *arrayname*.
     - Array *arrayname* can be either a numeric or string array. It is specified without following parenthesis.
     - Returns FC error if the array does not exist.
 - Note: Care should be taken when working with an array, because the addresses of arrays change whenever a new simple variable is assigned.
### EXAMPLES:
` A=44:COPY &A,&B,4:PRINT B `
> Assigns A a value, copies its contents from the address of A to a new address for B, and prints the value at that address.

` DIM A(9):PRINT &*A `
> Prints start address of array A() definition.

` PRINT PEEK(&A$) `
> Prints the length of A$.

` PRINT DEEK(&A$+2) `
> Prints the address of the text for A$.

` PRINT &&A$ `
> Also prints the address of the text for A$.


---
## AND
Bitwise AND
### FORMAT:
 - AND( *number1*, *number2* )
   - Action: Returns the bitwise AND of two numbers.
     - Both *number1* and *number2* must be between -32768 and 65535.
     - Can be used instead of AND operator which only allows operands between -32768 and 32767.
### EXAMPLE:
` PRINT AND(-1,$FFFF) `
> Prints 65535

---
## ASC$ Function
Convert Hexadecimal String to ASCII String
### FORMAT:
 - ASC$ ("*string*")
   - Action: Returns string whose characters ASCII values match the series of two digit hexadecimal numbers in *string*.
     - See the HEX$ function for string-to-hex conversion.
### EXAMPLE:
` PRINT ASC$("414243") `
> Prints the string "ABC".

---
## ATN
Arctangent
### FORMAT:
  - ATN ( *number* )
    - Action: This mathematical function returns the arctangent of the number. The result is the angle (in radians) whose tangent is the number given. The result is always in the range -pi/2 to +pi/2.
### EXAMPLES:
` PRINT ATN(1) `
> Prints the arctangent of 1, a value of `0.785398`

` X = ATN(J)*180/ {pi} `
> Defines variable X as the arctangent of another variable, J, divided by pi.

---
## CALL
Jump to and run machine code at specified address
### FORMAT:
 - CALL *address*
   - Action: Causes Z80 to jump from it's current instruction location to the specified one. Note that there must be valid code at the specified address, or the Aquarius will crash.
   - *address* can be a 16 bit signed or unsigned integer or hex value
### EXAMPLES:
` CALL $A000 `
> Begin executing machine code stored at upper half of middle 32k expansion RAM

` 10 LOAD "PRG.BIN",$A000 `

` 20 CALL $A000 `
> Loads raw binary code into upper 16k of 32k expansion, and then begins executing it.

---
## CAT
Catalog disk (quick DIR listing)
### FORMAT:
 - CAT
   - Action: Show a brief listing of all files and folders in the current directory.
     - File size, date, and time are not shown.
     - Directory names are shown in < >.
### EXAMPLE:
` CAT `
> List all files and folders in current directory in a 3-across format

---
## CD
Change directory / current path
### FORMAT:
 - CD
   - Action: show current path
 - CD "*dirname*"
   - Move into directory indicated by *dirname*
### EXAMPLES:
` CD "songs3" `
> Move into `songs3` (add `songs3` to current path)

` CD "/" `
> Move to root of the USB drive

` CD ".." `
> Back up one level to folder containing this one

` CD `
> Show the current path

---
## CD$
Get Current Directory path as a string
### FORMAT:
 - CD$
   - Action: Returns the current directory path as displayed by the CD command with no arguments
### EXAMPLES:
` PRINT CD$ `
> Prints the current directory path to the screen

` 10 A$=CD$:PRINT A$ `
> Assigns the current path string to A$, then prints it.

---
## CIRCLE
Draw circle or ellipse on screen.
### FORMAT:
  - CIRCLE(*xcenter*, *ycenter*), *radius*[,[*color*][,[*start*],[*end*][,*aspect*]]]
    - Action: Draws circle, elipse, or arc with given *radius* centered at *xcenter*, *ycenter*.
      - If *color* is not specified, the screen colors are maintained.
      - The *start* and *end* angle parameters are radian arguments between -2π and 2π which specify where the drawing of the ellipse is to begin and end.
        - If start or end is negative, the ellipse is connected to the center point with a line, and the angles are treated as if they are positive (note that this is different from adding 2π).
        - The start angle may be less than the end angle.
      - The option *aspect* describes the ratio of the x radius to the y radius (x:y).
        - The default aspect ratio gives a visual circle, assuming a standard monitor screen aspect ratio of 4:3.
        - If the aspect ratio is less than 1, then the radius is given in x-pixels. If it is greater than 1, the radius is given in y-pixels.
        - In many cases, an aspect ratio of 1 gives better ellipses. This also causes the ellipse to be drawn faster.
### EXAMPLES:
` CIRCLE(40,36),10,8 `
> Draws a grey circle in the center of the screen.

` CIRCLE(40,36),10,3,-0.75,-5.7,0.75 `
> Draws a popular arcade character in the middle of the screen

---
## CLEAR
Clear Variables and/or Error Code
### FORMAT:
  - CLEAR [ *number*, [ *address* ] ]
    - Action: Clears all variables and arrays, last arror number and line.
      - If *number* is specified allocates string space.
        - BASIC starts with 1024 bytes of string space allocated.
      - If *address* is specified, sets top of BASIC memory.
        - If 0, set to start of system variables minus one
        - FC Error if less than end of BASIC program plus 40 bytes
        - FC Error if greater than or equal to start of system variables
  - CLEAR ERR
    - Action: Clears last error number and line.
      - Leaves variables and arrays intact.
  - CLEAR DIM *array* [, *array* ...]
   - Action: Eliminates array from program.
     - Arrays may be redimensioned after they are ERASEd, or the previously allocated array spacein memory may be used for other purposes.
     - If an attempt is made to redimension an array without first ERASEing it, a "Redimensioned array" errors.
### EXAMPLES:
` CLEAR 2000 `
> Reserves 2000 bytes of space for strings.

` CLEAR 100, $A000 `
> Reserves 100 bytes for strings and sets top of BASIC memory to 40960

` CLEAR 500, 0 `
> Reserves 500 bytes for strings and sets to the maximum allowed

` CLEAR ERR `
> Sets last error number and line as returned by ERR(1) and ERR(2) to 0.

` CLEAR DIM A `
> Removes array A() from memory.

` 10 DIM B$(20) `
` 20 CLEAR DIM B$ `
` 30 DIM B$(10) `
> Dimensions B$ as a 20 unit string array, then ERASES it, then redimensions it as a 10 unit array.

---
## CLS (Extended)
Clear Screen / Clear Screen with specified foreground and background colors
### FORMAT:
 - CLS
   - Action: Clear the screen with defaut BLACK characters on CYAN background.
 - CLS [ *colors* ]
   - Action: Clears the screen. The optional *colors* parameter is a number between 0 and 255 that specifies the new foreground and background color combination using this formula with the values below:  (FG * 16) + BG:
>
    0 BLACK      4 BLUE       8  GREY        12 LTYELLOW
    1 RED        5 MAGENTA    9  DKCYAN      13 DKGREEN
    2 GREEN      6 CYAN       10 DKMAGENTA   14 DKRED
    3 YELLOW     7 WHITE      11 DKBLUE      15 DKGREY

   - The colors value can be represented as a two-digit hexadecimal number (preceded by a $ as a hex number designator) where the left digit is the foreground color and the right digit is the background color, using the following chart:
>
    0 BLACK      4 BLUE        8 GREY        C LTYELLOW
    1 RED        5 MAGENTA     9 DKCYAN      D DKGREEN
    2 GREEN      6 CYAN        A DKMAGENTA   E DKRED
    3 YELLOW     7 WHITE       B DKBLUE      F DKGREY

   - Warning: If the foreground and background colors are the same, typed and and PRINTed text will be invisible.
   - Advanced: Unlike PRINT CHR$(11), CLS does not clear memory locations 13288 - 13313 ($33E8 - $33FF) and 14312 - 14355 ($37E8 - $37FF).
### EXAMPLES:
` CLS `
> Clear screen with default colors

` CLS 7 `
> Clear screen - black text on white background

` CLS $30 `
> Clear screen - yellow text on black background

` CLS F*16+B `
> Clear screen - text color F, background color B (using BASIC variables)

---
## COPY (Extended)
Copy screen to Line Printer / Copy memory
### FORMAT:
  - COPY
    - Action: Sends screen contents to line printer (legacy command)
  - COPY *source*, *dest*, *count*
### EXAMPLES:
` COPY ` (no parameters)
> Send contents of screen to line printer

` COPY 12368,12328,920 `
> Scroll Screen Up One Line

` COPY 12288,12328,920 `
> Scroll Screen Down One Line

` COPY 12329,12328,39 `
> Scroll Row 1 right 1 char

` COPY $3000,$2000,2048 `
> Copy Screen and Colors to Low RAM

` COPY $2000,$3000,2048 `
> Restore Screen and Colors

---
## DEBUG
Enable the built-in Aquarius MX debugger
### FORMAT:
 - DEBUG
   - Action: Pauses current program and activates the debugger.
     - Debugger has a full onscreen menu within the debugger to aid in navigation.
     - While DEBUG can be called from within a BASIC program, it is geared towards Z80 machine code.
### EXAMPLES:
` DEBUG `
> Activates the Aquarius MX debugger from immediate mode.

` 10 ON ERROR GOTO 50 `

` 20 NEXT `

` 50 DEBUG `
> Set error trap line number to 50, cause a Next without For error, go into DEBUG mode.

---
## DEC
Hexadecimal to integer conversion
### FORMAT:
 - DEC(*hexadecimfal string*)
   - Action: Returns the DECimal value of the hexadecimal number in *hexadecimal string*.
     - If the first non-blank character of the string is not a decimal digit or the letters A through F, the value returned is zero.
     - String conversion is finished when the end of the string or any character that is not a hexadecimal digit is found.
     - See the HEX function for number-to-hex conversion.
### EXAMPLES:
` PRINT DEC("FFFF") `
> Prints "65535"

` 10 A$=HEX$(32):PRINT DEC(A$) `
> Prints "32"

---
## DEEK
Read 16 bit word from Memory
### FORMAT:
- DEEK(*address*)
  - Action: Reads a word from memory location *address*, returning a number between 0 and 65535.

### EXAMPLES:
` POKE DEEK(14337),PEEK(14349) `
> Remove cursor from screen.

` PRINT DEEK($384B) `
> Print the top of BASIC memory address.

---
## DEF FN / FN
Define User Function
### FORMAT:
  - DEF FN *name* ( *variable* ) = *expression*
    - Action: This sets up a user-defined function that can be used later in the program. The function can consist of any mathematical formula. User-defined functions save space in programs where a long formula is used in several places. The formula need only be specified once, in the definition statement, and then it is abbreviated as a function name. It must be executed once, but any subsequent executions are ignored.
      - The function name is the letters FN followed by any variable name. This can be 1 or 2 characters, the first being a letter and the second a letter or digit.
      - The parametern *variable* represents the argument variable or value that will be given in the function call and does not affect any program variable with the same name. For any other variable name in *expression*, the value of that program variable is used.
      - A DEF FN statement must be executed before the function it defines may be called. If a function is called before it has been defined, an "Undefined user function" error occurs.
      - Multiple user functions may be defined at once, each with a unique FN name. Executing a DEF with the same FN name as a previously defined user function replaces the previous definition with the new one. DEF FN is illegal in direct mode.
      - The function is called later in the program by using the function name with a variable in parentheses. This function name is used like any other variable, and its value is automatically calculated.
### EXAMPLES:
` 10 DEF FN A(X)=X+7 `

` 20 PRINT FN A(9) `
> Prints the value 16 (9 + 7)

` 10 DEF FN AA(X)=Y*Z `

` 20 R=FN AA(9) `
> Assigns R the value of X * Y, and the number 9 inside the parentheses does not affect the outcome of the function, because the function definition in line 10 doesn't use the variable in the parentheses.

` 10 DEF FN A9(Q) = INT(RND(1)*Q+1) `

` 20 G=G+FN A9(10) `
> Increments the value of G the rounded value of a random number between 1 and 10.

---
## DEL
Delete a file
### FORMAT:
 - DEL "*filename*"
   - Action: Deletes the file named *filename* from the current directory.
     - No warnings are given.
     - Wildcards and paths cannot be used.
     - Final quotation mark after string is optional.
### EXAMPLES:
` DEL "THISFILE.BAS" `
> Deletes the file named `THISFILE.BAS` from the current directory.

` 10 DEL "SAVEGAME.DAT" `
> Deletes the file named `SAVEGAME.DAT` from the current folder from within a program.

---
## DIR
Get a listing of the files on the current USB directory
### FORMAT:
 - DIR [ "*wildcard*" ]
   - Action: Show files in current directory with size, with an optional wildcard on filename
 - DIR SDTM [ "*wildcard*" ]
   - Action: Show files in current directory with size, date, and time, with optional *wildcard* on filename
   - Final quotation mark at end of *wildcard* string is optional.
### EXAMPLES:
` DIR `
> Show all files in current directory

` DIR "*.BAS" `
> Show BASIC program files in current directory

` DIR "*." `
> List all folder (or files without an extension) in current directory

` DIR SDTM "*A*" `
> Show any files with a letter A in the name, along with their last DateTime stamp

---
## DOKE
Writes 16 bit word(s) to memory location(s), aka "Double Poke"
### FORMAT:
 - DOKE *address*, *word*, [, *word* ...]
   - Action: Writes *word* to memory starting at *address*.
### EXAMPLES:
` DOKE 14340, 1382 `
> Set USR() function address

` DOKE $3028, $6162 `
> Put the characters `ba` at the top left of the screen

` DOKE $3028, $3130, $3332 `
> Put the characters `0123` at the top left of the screen

---
## DRAW
Draws a figure.
### FORMAT:
  - DRAW *string expression*
    - Action: The DRAW statement combines most of the capabilities of the other graphics statements into an object definition language called Graphics Macro Language (GML). A GML command is a single character within a string, optionally followed by one or more arguments.
#### Commands:
Each of the movement commands begins movement from the current graphics position.
 - This is usually the coordinate of the last graphics point plotted with another GML command, LINE, or PSET.
 - The current position defaults to upper right hand corner of the screen (0,0) when a program is run.
 - Movement commands move for a distance of scale factor *n, where the default for n is 1; thus, they move one point if n is omitted and the default scale factor is used.
| Command  | Action
|    Un    | Move up
|    Dn    | Move down
|    Ln    | Move left
|    Rn    | Move right
|    En    | Move diagonally up and right
|    Fn    | Move diagonally down and right
|    Gn    | Move diagonally down and left
|    Hn    | Move diagonally up and left
This command moves as specified by the following argument:
` Mx, y ` Move absolute or relative.
  - If x is preceded by a + or -, x and y are added to the current graphics position, and connected to the current position by a line.
  - Otherwise, a line is drawn to point x, y from the current position.
The following prefix commands may precede any of the above movement commands:
` B`  Move, but plot no points.
` N`  Move, but return to original position when done.
The following commands are also available:
` An  ` Set angle n.
- n may range from 0 to 3, where 0 is 0°, 1 is 90°, 2 is 180°, and 3 is 270°.
- Figures rotated 90° or 270° are scaled so that they will appear the same size as with 0° or 180° on a monitor screen with the standard aspect ratio of 4:3.
` TAn `  Turn angle n.
- n can be any value from negative 360 to positive 360.
- If the value specified by n is positive, it turns the angle counter-clockwise.
- If the value specified by n is negative, it turns clockwise.
` Cn  ` Set color n.
` Sn  ` Set scale factor n.
- n may range from 1 to 255. n is divided by 4 to derive the scale factor.
- The scale factor is multiplied by the distances given with U, D, L, R, E, F, G, H, or relative M commands to get the actual distance traveled.
- The default for S is 4.
`x*string* ` Execute substring.
- This command executes a second substring from a string, much like GOSUB. One string executes another, which executes a third, and so on.
- *string* is a variable assigned to a string of movement commands.
#### Numeric Arguments:
- Numeric arguments can be constants like "123" or "=variable;", where variable is the name of a variable.
- When you use the second syntax, "=variable;", the semicolon must be used. Otherwise, the semicolon is optional between commands.
### EXAMPLES:
```
  10 DRAW "BM 40,36"
  20 A=20: DRAW "R=A; D=A; L=A; U=A;"
```
> Moves to the center of the screen without drawing, then draws a box 11 pixels wide by 11 pixles high.
```
  30 PSET (10, 20)
  40 DRAW "E20; F20; L39"
```
> Draws a 42 pixel wide triangle with it's top vertex at x-coordinate 10 and y-coordinate 20.

---
## DTM$
Get DateTime
### FORMAT:
 - DTM$(*number*)
   - Action: If a Real Time Clock is installed:
     - If *number* is 0, returns a DateTime string "YYMMDDHHmmsscc"
     - Otherwise returns formatted times string "YYYY-MM-DD HH:mm:ss"
     - Returns "" if a Real Time Clock is not detected.
### EXAMPLES:
` PRIdNT DTM$(0) `
> 38011903140700

` PRINT DTM$(1) `
> 2038-01-19 03:14:07

` PRINT LEFT$(DTM$(1),10) `
> 2038-01-19

` PRINT RIGHT$(DTM$(1),8) `
> 03:14:07

` PRINT MID$(DTM$(1),6,11) `
> 01-19 03:14

---
## EDIT
Edit BASIC Line
### FORMAT:
 - EDIT *line number*
   - Action: Displays BASIC line *line number* on screen and enters edit mode. While editing a line, the following control keys are available:
```
  CTL - P   Move cursor left
  CTL - /   Move cursor right
    <--     Delete character to left
  CTL - \   Delete character to right
    RTN     Save changes and exit edit mode
  CTL - C   Discard changes and edit edit mode
  CTL - R   Retype previously entered IMMEDIATE MODE command
```

   - Note: The above control keys are also available when entering a new line or direct mode command.

---
## ERR
Error Status
### FORMAT:
  - ERR ( *number* )
    - Action: Returns error status values.
      - If *number* is -1, returns the line number to GOTO when an error occures.
        - Returns 0 if no error trapping is disabled.
      - If *number* is 0, returns the number corresponding to the last error.
        - - Returns 0 if no error has occured.
      - If *number* is 1, returns the line number the last error occured on.
        - Returns 0 if no error has occured.
        - Returns 65535 if the error occured in immediate mode.
      - If *number* is 2, returns the number corresponding to the last DOS error.
        - Returns 0 if the last DOS command completed successfully.
      - If *number* is 3, returns the status code of the last CH376 operation.
        - This may not be directly related to the DOS error number.
      - Returns FC Error if *number* is none of the above

### Basic Error Numbers
| Err# | Code | Description                  |
|------|------|------------------------------|
|   1  |  NF  | NEXT without FOR             |
|   2  |  SN  | Syntax error                 |
|   3  |  RG  | RETURN without GOSUB         |
|   4  |  OD  | Out of DATA                  |
|   5  |  FC  | Function Call error          |
|   6  |  OV  | Overflow                     |
|   7  |  OM  | Out of Memory                |
|   8  |  UL  | Undefined Line number        |
|   9  |  BS  | Bad Subscript                |
|  10  |  DD  | Re-DIMensioned array         |
|  11  |  /0  | Division by Zero             |
|  12  |  ID  | Illegal direct               |
|  13  |  TM  | Type mismatch                |
|  14  |  OS  | Out of String space          |
|  15  |  LS  | String too Long              |
|  16  |  ST  | String formula too complex   |
|  17  |  CN  | Cant CONTinue                |
|  18  |  UF  | UnDEFined FN function        |
|  19  |  MO  | Missing operand              |
|  20  |  IO` | Disk I/O error               |
|  21  |  UE  | Unprintable error            |

### DOS Error Numbers
| Err# | Error Message       | Description                    |
|------|---------------------|--------------------------------|
|   1  | no CH376            | CH376 not responding           |
|   2  | no USB              | Not in USB mode                |
|   3  | no disk             | USB Drive mount failed         |
|   4  | invalid name        | Invalid DOS file name          |
|   5  | file not found      | File does not exist            |
|   6  | file empty          | File does not contain data     |
|   7  | filetype mismatch   | File is not in CAQ format      |
|   8  | remove dir error    | Unable to remove directory     |
|   9  | read error          | Error while reading USB drive  |
|  10  | write error         | Error while writing USB drive  |
|  11  | file create error   | Unable to create file          |
|  12  | directory not found | Unable to open directory       |
|  13  | path too long       | Path is too long               |
|  14  | disk error #xx      | Other disk error               |


---
## ERR$
Error Status
### FORMAT:
  - ERR$ ( *number* [, *error*] )
    - Action: Returns string containing description of error
      - If *number* is 0, returns a two character BASIC error code.
      - If *number* is 1, returns a BASIC error description
      - If *number* is 2, returns a DOS error description
    - If second argument *error* is included, prints the description for that error number.
      - Otherwise, prints the description corresponding to the value returned by ERR(*number*).
      - Returns an empty string if *error* or ERR(*number*) is 0.
      - Returns FC Error if *error* or ERR(*number*) is less than 0.
### EXAMPLES:
`

---
## ERROR
Trigger a BASIC Error
### FORMAT:
 - ERROR *error*
   - Action: Triggers a BASIC Error.
     - *error* is the error number of the error to trigger (see ERR function)
     - FC Error results if *error* is not between 0 and 255, inclusive
     - if *error* is 0, no error is triggered
### EXAMPLES:

---
## EVAL
Evaluate a formula in a string.
### FORMAT:
 - EVAL(*formula*)
   - Action: Outputs the results of *formula* as a string
### EXAMPLE:
` PRINT EVAL("7 + 4") `
> Prints "11"


---
## FILE$
Get Last Filename
### FORMAT:
 - FILE$
   - Action: Returns the
### EXAMPLES:
` PRINT FILE$ `
> Prints the name of the last file accessed.

---
## FRE (Extended)
Show available Memory / Show memory details
### FORMAT:
 - FRE ( 0 )
   - Action: Returns the number of bytes in memory not being used by BASlC.
 - FRE ( 1 )
   - Action: Returns  the total size of string space (as set by the first argument of CLEAR).
 - FRE ( 2 )
   - Action: Returns returns the top of BASIC memory (as set by the second argument of CLEAR).
 - FRE ( 3 )
   - Action: Returns the top of user memory (the highest value allowed for CLEAR).
 - FRE ( *string* )
   - Action: Forces a garbage collection before returning the number of free bytes of string space.
     - BASIC will not initiate garbage collection until all free memory has been used up.
     - Therefore, using FRE("") periodically will result in shorter delays for each garbage collection.
  - Any other argument returns an FC error.
### EXAMPLE:
` PRINT FRE(0) `
> Displays amount of free remaining memory available to BASIC.

` PRINT HEX$(FRE(2)) `
> Displays the current top address of BASIC memory as a hexadecimal format address.

---
## GET Statement
Copy a rectangle of screen data to a numeric array.
### FORMAT:
 - GET (*x1*,*y1*)-(*x2*,*y2*),*arrayname*
   - Action: Copies a rectangle of screen characters and colors to numeric array *arrayname*.
     - The rectangle's upper left corner is at column *x1* on line *y1* and lower right corner is at column *x2* on line *y2*
     - *arrayname* must already be DIMensioned to a size large enough to hold the data.
       - To calculate the size of an array needed to store the elements in a rectangle:
         - Multply the width of the rectangle in rows by the height in LINES
         - Round up to an even number
         - Divide by two
     - Can also be combined with LOAD array* and SAVE array* to import/export "sprite" graphics from/to USB drive.
     - See PUT statement for copying from array to screen.
 - Advanced: The screen data (CHRRAM and COLRAM) is stored in the array as binary data.
### EXAMPLE:
```
10 DIM A(8)
20 GET (1,1)-(4,4),A
30 SAVE "CURSOR.SPR",*A
```
> Saves the contents of a 4x4 character/color grid at the upper left of the screen to file CURSOR.SPR.

---
## HEX$
Integer to hexadecimal conversion
### FORMAT:
 - HEX$(*number*)
   - Action: Returns string containing *number* in two-byte hexadecimal format.
     - FC Error if *number* is not in the range -32676 through 65535.
     - See the DEC function for hex-to-number conversion.
 - HEX$("*string*")
   - Action: Returns string containing a series of two digit hexadecimal numbers representing the characters in *string*.
     - Length of returned string is twice that *string*.
     - LS Error results if length of *string* is greater than 127.
     - See the ASC$ function for hex-to-string conversion.
### EXAMPLES:
` PRINT HEX$(1) `
> Prints "0001"

` 10 PRINT HEX$(PEEK(12288)) `
> Prints the HEX value of the border char (usually "0020", SPACE character)

---
## Hexadecimal Constants
 - A hexadecimal constant is a value between 0 and 65535, inclusive. It consists of a dollar sign followed by 1 to 4 hexadecimal digits.
   - Hexadecimal constants may be used in any numeric expression or anywhere a numeric expression is allowed.
   - They may not be used in DATA statements, as entries to the INPUT statement, in string arguments to the VAL() function, or as the target of a GOTO or GOSUB statement.
### EXAMPLES:
` PRINT $FFFF `
> Prints 65535

` A = $101 `
> Sets A to 257

` P = $3000+40*R+C `
> Sets P to screen row 1, column 1 address

---
## IN
Read Z80 I/O Port
### FORMAT:
 - IN(*address*)
   - Action: Reads a byte from the I/O port specified by LSB of *address*.
   - Advanced: During the read, *address* is put on the Z80 address bus.
### EXAMPLES:
` PRINT IN(252) `
> Prints cassette port input status

` S=IN($FE) `
> Set variable S to Printer Ready status

---
## INSTR Function
Search for string in another string
### FORMAT:
 - INSTR ( [ *offset* , ] *string1* , *string2* )
   - Action: Searches for the first occurrence of *string2* in *string1* and returns the position at which the match is found.
     - Optional *offset* sets the position for starting the search.
       - Must be in the range 1 to 255 or an FC Error results.
     - If *offset* > LEN(*string1*) or if *string1* is null or if *string2* cannot be found, INSTR returns 0.
     - If *string2* is null, INSTR returns *offset* or 1.
     - *string1* and *string2* may be string variables, string expressions or string literals.
### EXAMPLE:
```
  10 X$ = "ABCDEB"
  20 Y$ = "B"
  30 PRINT INSTR(X$,Y$) ;INSTR(4,X$,y$)
```
> Prints the numbers 2 and 6.

---
## JOY
Read AY-3-8910 Control Pad Inputs
### FORMAT:
 - JOY(*stick*)
   - Action: Reads integer input value from *stick*, where:
     - `0` will read left or right control pad
     - `1` will read left control pad only
     - `2` will read right control pad only
### EXAMPLES:
` PRINT JOY(0) `
> Prints input value of either/both control pads (not effective in immediate mode).

```
10 PRINT JOY(1)
20 GOTO 10
```
> Continuously reads and prints the input value from only the left control pad.

---
## KEY
Read Keyboard
### FORMAT:
 - KEY(*number*)
   - Action: Checks for a key press and returns the ASCII code of the key.
     - If *number* is 0, waits for a key to be pressed then returns it's ASCII code.
     - If *number* is positive, checks to see if a key has been pressed, returning the key's ASCII code (or 0 if no key was pressed). A key press will only be detected once, returning 0 on subsequent calls until the key is released and pressed again.
     - If *number* is negative, returns the ASCII code of the key currently being pressed (or 0 if no keys are being pressed). Subsequent calls will continue to return the key's ASCII code if the key remains pressed.
     - KEY() does not expand control-key combinations to keywords. Instead CTRL-A through CTRL-Z generate ASCII 1 through 27 (^A-^Z) The rest of the control characters are assigned as follows:
```
  KEY:  ;   =   0   :   /   -  8   9   7   ,   1   .   2  <--
ASCII: 128  27  28  29  30  31 91  93  96 123 124 125 126 127
 NOTE:  ^@ ESC  ^\  ^]  ^^  ^_ [   ]   `  {    |   }   ~  DEL

  KEY:   3    4    5    6   SPACE  RTN  Shift-SPC  Shift-RTN
ASCII:  158  143  159  142   $C6   255     160        134
 NOTE: LEFT  UP  DOWN RIGHT  dot  black   blank   checkerboard
```

### EXAMPLES:
` PRINT KEY(0) `
> Wait for a key press then print ASCII code

` 10 K=KEY(1) `

` 20 IF K THEN S$=S$+CHR$(K) `
> Check for key press and add key character to string once per key press

` 10 K=KEY(-1) `

` 2O IF K=97 THEN X=X-1 `

` 30 IF K=115 THEN X=X+1 `
> Continously decrement or increment X as long as the A or S key, respectively, is pressed.

---
## KEY Statement
Controls keyboard functions
### FORMAT:
 - KEY SOUND [ON | OFF]
   - Action: Turns key click ON or OFF
 - KEY *string*
   - Action: Causes BASIC to act as though the characters in *string* are being typed on the keyboard.
     - Returns LS Error if *string* is longer than 15 characters.

### EXAMPLES:
` KEY SOUND OFF `
> Turns key click off.

` KEY SOUND ON `
> Turns key click on.

---
## LINE Statement
Draw line or box on screen.
### FORMAT:
  - LINE [ (*x-coord1*,*y-coord1*) ] - ( *x-coord2*,*y-coord2*) [ ,[ *color* ] [,B[F] ]
    - Action: Draws line from the first specified point to the second specified point.
      - If the first (*x-coord1*,*y-coord1*) is ommited (starts with a dash), the line starts at the last referenced point.
      - B (box) draws a box with the specified points at opposite corners.
      - BF (filled box) draws a box (as ,B) and fills in the interior with points.
      - If *color* is not specified, the current screen colors are maintained and two commas must be used before B or BF
### EXAMPLES:
` LINE (0,36)-(79,36) `
> Draws a horizontal line which divides the screen in half from top to bottom.

` LINE (40,0)-(40,71) `
> Draws a vertical line which divides the screen in half from left to right.

` LINE (0,0)-(79,71) `
> Draws a diagonal line from the top left to lower right corner of the screen.

` LINE (10,10)-(20,20),2 `
> Draws a line in color 2.

```
10 CLS
20 LINE -(RND*80,RND*72),RND*16
30 GOTO 20
```
>  Draw lines forever using random attributes.

---
## LOAD (Updated)
Load File from USB Drive
### FORMAT:
 - LOAD "*filespec*"
   - Action: Load BASIC program *filespec* into memory
     - *filename* can be any string expression
     - If *filename* is shorter than 9 characters and does not contain a ".", the extension ".BAS" is appended.
     - File on USB drive must be in CAQ format. The internal filename is ignored.
 - LOAD *filespec* , \**arrayname*
   - Action: Load contents of array file *filespec* into array *arrayname*
     - If *filename* is shorter than 9 characters and does not contain a ".", the extension ".CAQ" is added.
     - File on USB drive mus be in CAQ format with the internal filename "######".
 - LOAD *filespec* , *address* [ , *length* [, *offset*]]
 - LOAD "*filespec*" , \**arrayname*
   - Action: Load contents of array file *filespec* into array *arrayname*
 - LOAD "*filespec*" , *address* [ , *length* [, *offset*]]
   - Action: Load contents of binary file *filespec* into memot
     - *length* specifies the number of bytes to load from the file
     - *offset* specifies the position in the file to start loadin from
     - If no parameters other than filename are used, the second quotation mark after *filespec* is optional.
### EXAMPLES:
` LOAD "progname.bas" `
> Load basic program into memory.

` LOAD "array.caq",*A `
> Load contents of file into array A().

` LOAD "capture.scr",12288 `
> Loads the file "capture.scr" into SCREEN RAM.

---
## LOCATE
Move the cursor to a specific column and row on the screen
### FORMAT:
 - LOCATE *column*,*row*
   - Action: Moves the cursor to the specified spot on the screen
     - *column* can be 1-38 (leftmost and rightmost columns cannot be used)
     - *row* can be 1-23 (topmost and bottommost rows cannot be used)
### EXAMPLES:
` LOCATE 1,1:print"Hello" `
> Prints `Hello` at top left of screen

` CLS:LOCATE 19,11:PRINT"&" `
> Clears the screen and prints `&` in the middle

---
## MENU
Display and execute menu.
### FORMAT:
  - MENU ( *xpos*,*ypos*) [, *spacing*;] *string* [,*string*,...] GOTO *line*, [,*line*...]
    - Action: This mathematical function returns the arctangent of the number. The result is the angle (in radians) whose tangent is the number given. The result is always in the range -pi/2 to +pi/2.
### EXAMPLES:

---
## MID$ Statement
  Replace a portion of one string with another string.
### FORMAT:
 - MID$ ( *var$* , *pos* [ , *len*] ) = *string*
   - Action: The contents of string variable *var$*, beginning at position *pos*, are replaced by the characters in *string*
     - if *pos* is less than 1 or more than 255, an FC error results
     - The optional *len* refers to the number of characters from *string* that will be used in the replacement
     - If *len* is omitted, all of *string* is used.
     - Regardless of whether *len* is omitted or included, the replacement of characters never goes beyond the original length of *var$*.
### EXAMPLE:
```
10 A$="KANSAS CITY, MO"
20 MID$(A$,14) ="KS"
30 PRINT A$
```
> Prints ` KANSAS CITY, KS `

---
## MKDIR
Create directory in current path
### FORMAT:
 - MKDIR "*dirname*"
   - Action: Create directory *dirname* in the current directory (see CD).
     - Returns without error if directory already exists.
     - Returns Disk I/O Error "file exists" if a file with the same name is in the current directory.
### EXAMPLE:
` MKDIR "mydir" `
> Creates new directory MYDIR in the current directory.

---
## ON ERROR
BASIC error handling function and codes
### FORMAT:
  - ON ERROR GOTO *line number*
    - Action: details
### EXAMPLE:
` 10 ON ERROR GOTO 100 `

` 20 NEXT `

` 30 REM I get skipped `

` 100 PRINT ERR(0) `

` 110 PRINT ERR(1) `

` 120 PRINT ERR(2) `
> Sets line 100 as the error handler, forces an error (NEXT without FOR) in line 20, then jumps to 100 and prints `100` for the error handler line, then the error number, then the line the error occured on `20`.

---
## OR
Bitwise OR
### FORMAT:
 - OR( *number1*, *number2* > )
   - Action: Returns the bitwise OR of two numbers.
     - Both *number1* and *number2* must be between -32768 and 65535.
     - Can be used instead of OR operator which only allows operands between -32768 and 32767.
### EXAMPLE:
` PRINT HEX$(OR($8080,$0808)) `
> Prints 8888

---
## OUT
Write to Z80 I/O Port
### FORMAT:
 - OUT *address*,*byte*
   - Action: Writes *byte* to the I/O port specified by LSB of *address*.
   - Advanced: During the write, *address* is put on the Z80 address bus.
### EXAMPLES:
` OUT 246, 12 `
> Send a value of 12 to the SOUND chip

` 10 X=14:OUT $FC, X `
> Send a value of 14 to the Cassette sound port

---
## PEEK Function
Read Byte from Memory
### FORMAT:
 - PEEK( *address* )
   - Action: Returns contents of memory location *address*.
### EXAMPLES:
` PRINT CHR$(PEEK(12288)) `
> Print the current border character

` PRINT PEEK($3400) `
> Print the current border color value

---
## PEEK$ Function
Read String from Memory
### FORMAT:
 - PEEK( *address*, *length* )
   - Action: Returns a string containing *length* bytes from memory starting at location *address*.
     - Length must be between 0 and 255, inclusive.
     - If length is 0, an empty string is returned.
### EXAMPLES:
` PRINT PEEK$(12328,40) `
> Print the contents of screen line 1.

` PRINT HEX$(PEEK$(&A,4)) `
> Print the binary value floating point number in variable A as a hexadecimal number.

---
## POKE (Extended)
Writes byte(s) to memory location(s)
### FORMAT:
 - POKE *address*, [ *byte or string*, *byte or string*... ] [,STEP *count*, *byte or string*...]
   - Action: Writes *byte or string* to *address*, followed by *address* STEP *count* addresses away...
 - POKE *address1* TO *address2*, *byte*
   - Action: Writes *byte* to memory from *address1* TO *address2*.
### EXAMPLES:
` POKE $3000+500,64 `
> Display `@` at screen center

` POKE 12347,7,6 `
> Display double-ended arrow

` POKE 12366,$13,STEP 39,$14 `
> Display standing person "sprite"

` POKE 12329,$D4,STEP 1023,$10 `
> Display red heart on black background

` POKE $3009,T$,5,C$ `
> Display T$, copyright, C$ on row 0

` POKE $3400 TO $3427,5 `
> Set border color to magenta

` POKE $3028 TO $33E7,$86 `
> Fill screen with checkerboard character

---
## PRESET
Erase a pixel
### FORMAT:
  - PRESET [STEP] (*x-coord*,*y-coord*)
    - Action: Erases a pixel from the screen.
### EXAMPLES:
` PRESET (20,10) `
> Erases the pixel at column 20 of line 10.

` PRESET STEP (0,0) `
> Erases the pixel at the last referenced coordinates.

---
## PSET
Draw a pixel
### FORMAT:
  - PSET [STEP] (*x-coord*,*y-coord*) [ , *color* ]
    - Action: Draws a pixel on the screen.
### EXAMPLES:
` PSET (20,10) `
> Draws a pixel at x-coordinate 20 and y-coordinate 10.
` PSET (40,36),3 `
> Draws a yellow pixel at the center of the screen.

` PSET (-10,8) `
> Draws a pixel at 10 points to the left of and 10 points below the last referenced Coordinates.

---
## PSG
Write to Programmable Sound Generator(s)
### FORMAT:
 - PSG *register*, *value* [, ...]
   - Action: Writes a *register* *value* pair to either PSG1 or PSG2
     - *register*  0-15 goes to PSG1 at $F7 (register) and $F6 (data)
     - *register* 16-31 goes to PSG2 at $F9 (register) and $F8 (data)
### EXAMPLES:
` PSG 8,15,0,148,1,1,7,56 `
> Play a Db4 note on PSG1 channel A, continuously

` PSG 8,0,7,0 `
> Turn the PSG1 sound off

` PSG 24,15,16,148,17,1,23,56 `
> Play a Db4 note on PSG2 channel A, continuously

` PSG 24,0,23,0 `
> Turn the PSG2 sound off

---
## PUT Statement
Copy data from a numeric array into a rectangle of screen data.
### FORMAT:
 - PUT (*x1*,*y1*)-(*x2*,*y2*),*arrayname*
   - Action: Copies bytes from *arrayname* into a a rectangle of screen characters and colors.
     - The rectangle's upper left corner is at column *x1* on line *y1* and lower right corner is at column *x2* on line *y2*
     - *arrayname* must already be DIMensioned to a size large enough to hold the data, and populated with data.
       - To calculate the size of an array needed to store the elements in a rectangle:
         - Multply the width of the rectangle in rows by the height in LINES
         - Round up to an even number
         - Divide by two
     - Can also be combined with LOAD array* and SAVE array* to import/export "sprite" graphics from/to USB drive.
     - See GET statement for copying from screen to array.
 - Advanced: The screen data (CHRRAM and COLRAM) is stored in the array as binary data.
### EXAMPLE:
```
10 DIM A(8)
20 LOAD "CURSOR,SPR",*A
30 PUT (1,1)-(4,4),A
```
> Loads a file into array A, then displays the contents of in a 4x4 character/color grid at the upper left of the screen.

---
## RUN
Loads and runs BASIC programs (*.CAQ or *.BAS)
### FORMAT:
 - RUN *filename*
   - Action: Loads program into memory and runs it.
     - If *filename* is shorter than 9 characters and does not contain a ".", the extension ".BAS" is appended.
     - File on USB drive must be in CAQ format. The internal filename is ignored.
 - RUN "*filename*"
   - Action: Loads program named *filename* into memory and runs it.
     - If executed from within another BASIC program, the original program is cleared (same as NEW command) and the new program is loaded and excuted in it's place.
     - Wildcards and paths cannot be used.
### EXAMPLES:
` RUN "RUN-ME" `
> Loads and runs the file named `RUN-ME.BAS`. Note the program must exist within the current folder path.

` 10 PRINT "Loading Program..." `

` 20 RUN "NEXTPRG.CAQ" `
> Displays "Loading Program..." on screen and then immediately loads and runs the `NEXTPRG.CAQ` program.

---
## SAVE (Updated)
Save File to USB Drive
### FORMAT:
 - SAVE "*filename*"
   - Action: Save BASIC programt to file *filename* on USB drive.
     - *filename* can be any string expression
     - If *filename* is shorter than 9 characters and does not contain a ".", the extension ".BAS" is appended.
     - File on USB drive will be in CAQ format with the internal filename set to the first 6 characters of *filename*.
 - SAVE "*filespec*",\**arrayname*
   - Action: Save BASIC programt to file *filename* on USB drive.
     - If *filename* is shorter than 9 characters and does not contain a ".", the extension ".CAQ" is added.
     - File on USB drive will be in CAQ format with the internal filename set to "######".
 - SAVE *filespec*,*address*,*length*[,*offset*]
   - Action: Saves *length* bytes of memory starting at *address* to file *filename* on USB drive.
### EXAMPLES:
` SAVE "progname" `
> Save current program to USB drive with file name "PROGNAME.BAS"

` SAVE "progname." `
> Save current program to USB drive with file name "PROGNAME"

` SAVE "progname.caq" `
> Save current program to USB drive with file name "PROGNAME.CAQ"

` SAVE "array",*A `
> Save contents of array A() to USB drive with file name "ARRAY.CAQ"

` SAVE "capture.src",12288,2048 `
> Save Screen and Color RAM as raw binary file

---
## SDTM
Set DateTime
### FORMAT:
 - SDTM "*string*"
   - Action: If a Real Time Clock is installed, allows user to set the time on the Dallas DS1244Y RTC. DateTime string must be listed in "YYMMDDHHMMSS" format:
        - Improperly formatted string causes FC Error
        - DateTime is set by default to 24 hour mode,
          with cc (hundredths of seconds) set to 0
### EXAMPLES:
` SDTM "230411101500" `
> Sets DateTime to 11 APR 2023 10:15:00 (24 hour format)

` 10 SDTM "010101000000" `
> Sets DateTime to 01 JAN 2001 00:00:00 (24 hour format)

---
## SLEEP
Pause program execution.
### FORMAT:
 - SLEEP *number*
   - Action: Causes BASIC to pause for approximately *number* milliseconds.
     - If *number* is less than zero, pauses 65536 - *number* seconds
     - Returns FC Error if *number* is not between -32768 and 65535, inclusive.
     - Ctrl-C will interrupt the SLEEP command and the BASIC Program
### EXAMPLES:
` SLEEP 250 `
> Pauses for 1/4 second.

` SLEEP S `
> Pauses for S / 1000 seconds.

---
## STRING$
Create string of repeating characters.
### FORMAT:
 - STRING$ (*length*)
   - Action: Returns a string of *length* whose characters all spaces (ASCII code 32).
 - STRING$ (*length*, *byte* )
   - Action: Returns a string of *length* whose characters all have ASCII code *byte*.
 - STRING$ (*length*, *string* )
   - Action: Returns a string of *length* whose characters are all r the first character of *string*.
### EXAMPLE:
```
  10 X$ = STRING$ (10 , 45)
  20 PRINT X$ "MONTHLY REPORT" X$
  RUN
  ----------MONTHLY REPORT----------
  OK
```

---
## SWAP
Swap variable contents.
### FORMAT:
 - SWAP *variable1*, *variable2*
   - Action: Exchanges the values of two variables.
     - The variables must be of the same type or a TM error results.
### EXAMPLE:
```
  10 A$=" ONE " : B$=" ALL ": C$="FOR"
  20 PRINT A$ C$ B$
  30 SWAP A$, B$
  40 PRINT A$ C$ B$
  RUN
  ONE FOR ALL
  ALL FOR ONE
```

---
## VER
Returns 16 bit integer value of MX BASIC ROM version
### FORMAT:
 - VER(0)
   - Action: Returns integer of current MX BASIC ROM version
### EXAMPLES:
` PRINT VER(0) `
> Prints `512`

` PRINT HEX$(VER(0)) `
> Prints `0200`, the HEX value of version 2, rev 0

---
## WAIT Statement
Suspend program execution while monitoring the status of a Z80 input port.
### FORMAT:
 - WAIT *address*, *byte1* [, *byte2*]
   - Action: Causes execution to be suspended until a Z80 port develops a specified bit pattern.
     - The I/O port to read is specified by the LSB of *address*
     - The data read at the port is Exclusive OR'ed with *byte2*, then AND'ed with *byte1*.
     - If the result is zero, MX BASIC loops back and reads the data at the port again.
     - If the result is nonzero, execution continues with the next statement.
     - If *byte2* is omitted, it is assumed to be zero
   - Advanced: During the read, *address* is put on the Z80 address bus.
   - Caution: WAIT is not interrupted by Control-C. The RST key must be used to exit a WAIT that is in an infinite loop.
### EXAMPLE:
` WAIT $FF,$3F,$FF `
> Wait for any key to be pressed.

---
## XOR
Bitwise Exclusive OR
### FORMAT:
 - XOR( *number1*, *number2* )
   - Action: Returns the bitwise Exlusive OR of two numbers.
     - Both *number1* and *number2* must be between -32768 and 65535.
### EXAMPLE:
` PRINT HEX$(XOR($FFFF,$0808)) `
> Prints F7F7

